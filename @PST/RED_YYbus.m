function [Y11,Y12,Y21,Y22,rec_V1,rec_V2,bus_order] =...
                          RED_YYbus(bus_sol,line)
% Syntax:  [red_Y,rec_V] = RED_YYbus(bus_sol,line)                                     
%          [Y11,Y12,Y21,Y22,rec_V1,rec_V2,bus_order] =...
%                          RED_YYbus(bus_sol,line)
% Purpose: form the reduced admittance matrix
%
% Input:    bus_sol   - bus solution (generated by loadflow)
%           line      - line data
%
% Output:   red_Y     - reduced admittance matrix
%           rec_V     - voltage reconstruction matrix
%           Y11,Y12,Y21,Y22 - reduced admittance matrix for
%                         systems with non-conforming loads
%           rec_V1, rec_V2 - voltage reconstruction bus
%           bus_order - vector of bus number for recovering
%                       bus voltages
% See also: PST.pst_var, loadflow, ybus
%
% Calls: yybus
%
% Call By:  

% (c) Copyright 1991 Joe H. Chow - All Rights Reserved
%
% History (in reverse chronological order)
%
% Version:   1.0
% Author:    Kwok W. Cheung, Joe H. Chow
% Date:      March 1991
%
% ***********************************************************

global basmva bus_int mac_int mac_con load_con

jay = sqrt(-1);
swing_bus = 1;
gen_bus = 2;
load_bus = 3;

nline = length(line(:,1));     % number of lines
nbus = length(bus_sol(:,1));     % number of buses
[n,dummy] = size(mac_con);     % number of machine
m = nbus - n;     % total number of PQ buses

% build admittance matrix Y
Y_d = PST.YYbus(bus_sol,line); % bus admittance matrix construction
                       
%  Compute constant impedance component of non-conforming loads
if nargout > 2
  [nload dum] = size(load_con);
  j = bus_int(load_con(:,1));
  bus_sol(j,6) = (ones(nload,1)-load_con(:,2)-load_con(:,4)).*bus_sol(j,6);                   
  bus_sol(j,7) = (1-load_con(:,3)-load_con(:,5)).*bus_sol(j,7);                 
end
%  Add load components to Y matrix
V = bus_sol(:,2);      % magnitude of terminal voltage
Pl = bus_sol(:,6);     % real power of loads
Ql = bus_sol(:,7);     % reactive power of loads
% Modify load component to take into account generation
% buses with no generator data
gen_exist = false(max(bus_sol(:,1)),1);
for i=1:n              
  gen_exist(round(mac_con(i,2))) = true;
end
for i=1:nbus
  if ~gen_exist(round(bus_sol(i,1)))
    Pl(i) = Pl(i) - bus_sol(i,4);  %convert generation not in mac_con(:,:)
    Ql(i) = Ql(i) - bus_sol(i,5);  %to negative load
  end
end
yl = (Pl - jay*Ql)./V.^2;
ii = [1:1:nbus]';
y1 = sparse(ii,ii,yl,nbus,nbus);
%Y_d = Y_d + diag(yl);
Y_d = Y_d + y1;

% extract appropriate xdprime and xdpprime from machine data
%for i = 1:n
%  if mac_con(i,8) ~= 0
%      xd(i) = mac_con(i,8)*basmva/mac_con(i,3);
%    else
%      xd(i) = mac_con(i,7)*basmva/mac_con(i,3);
%  end
%end
% take resistance r_a into account
for i = 1:n
  if mac_con(i,8) ~= 0
    xd(i) = (mac_con(i,5)+jay*mac_con(i,8))*basmva/mac_con(i,3);
  else
    xd(i) = (mac_con(i,5)+jay*mac_con(i,7))*basmva/mac_con(i,3);
  end
end
%y = ones(n,1)./(jay*xd');     
y = ones(1,n)./xd; 

%Y_a = diag(y);        % generator admittance matrix
iin = [1:1:n]';
Y_a = sparse(iin,iin,y,n,n);
Y_b = sparse(1,1,0,n,nbus); 
gen_int = [];
for i = 1:n
  j = bus_int(round(mac_con(i,2)));  % bus connected to generator
  gen_int = [gen_int; j];
  Y_b(i,j) = -y(i);
  Y_d(j,j) = Y_d(j,j) + y(i);
end
lod_int = setdiff(nonzeros(bus_int), gen_int);
Y_c = -Y_b'; % ' is complex conjugate transpose

% set up internal machine list
macmax = max(mac_con(:,1));
mac_int = zeros(macmax,1);
for i = 1:n
  mac_int(round(mac_con(i,1))) = i;  %not so optimized, because you are
end                                  %using a vector of macmax size for 
	                             %just n non-zero elements

% form the reduced admittance matrix
if nargout <= 2   
    Y12 = -Y_d\Y_c;
    Y11 = full(Y_a + Y_b*Y12);
    Y12 = full(Y12);
    
    % y11 = Y_d(gen_int,gen_int);
    % y12 = Y_d(gen_int,lod_int);
    % y21 = Y_d(lod_int,gen_int);
    % y22 = Y_d(lod_int,lod_int);
    % tmp = y22\y21;
    % Y11 = y11 - y12*tmp;    
  else 
  % non-conforming load Y matrix reduction
  % make vector with non-conforming load buses first
    bus_order = zeros(nbus,1);
    bus_order(1:nload,1) = bus_int(load_con(:,1));
    bus_conf = zeros(nbus,1); % constant impedance bus
                              % indicator
    for i = 1:nload
       bus_conf(bus_order(i)) = 1;
    end
    k = nload;
    for i = 1:nbus
      if bus_conf(i) == 0
        k = k+1;
        bus_order(k) = i;
      end
    end
  % make permutation matrix
    P = sparse(1,1,0,nbus,nbus);
    for i = 1:nbus
      P(i,bus_order(i)) = 1;
    end
  % apply permutation matrix to Y matrix
    Y_b = Y_b*P'; Y_c = P*Y_c; Y_d = P*Y_d*P';  
  % partition Y matrices
    Y_b1 = Y_b(:,1:nload); Y_b2 = Y_b(:,nload+1:nbus);
    Y_c1 = Y_c(1:nload,:); Y_c2 = Y_c(nload+1:nbus,:);
    Y_d1 = Y_d(1:nload,:); Y_d2 = Y_d(nload+1:nbus,:);
    Y_d11 = Y_d1(:,1:nload); Y_d12 = Y_d1(:,nload+1:nbus);
    Y_d21 = Y_d2(:,1:nload); Y_d22 = Y_d2(:,nload+1:nbus);
    %yinv = inv(Y_d22);
    %rec_V1 = -yinv*Y_c2; rec_V2 = -yinv*Y_d21;
    rec_V2 = -Y_d22\[Y_c2 Y_d21];
    rec_V1 = rec_V2(:,1:n); rec_V2 = rec_V2(:,n+1:n+nload);
    Y11 = full(Y_a + Y_b2*rec_V1); 
    Y12 = full(Y_b1 + Y_b2*rec_V2);
    Y21 = full(Y_c1 + Y_d12*rec_V1);
    Y22 = full(Y_d11 + Y_d12*rec_V2);
end

return